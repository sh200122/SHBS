class NativeDataCache {
    constructor() {
        this.cache = new Map();
    }
    keys() {
        return Array.from(this.cache.keys());
    }
    set(key, value) {
        this.cache.set(key, value);
    }
    get(key) {
        return this.cache.get(key);
    }
    delete(key) {
        return this.cache.delete(key);
    }
    has(key) {
        return this.cache.has(key);
    }
}
/**
 * 同步数据缓存ProxyHandler
 */
class SyncCacheProxyHandler {
    constructor(nativeApi) {
        this.enableMethodNames = new Set();
        this.nativeApi = nativeApi;
        this.cache = new NativeDataCache();
        // 绑定类的this到self变量
        const self = this;
        // 监听Native数据变化
        this.listener = {
            register: (methodNames) => {
                methodNames.forEach((name) => {
                    self.enableMethodNames.add(name);
                });
            },
            unregister: (methodNames) => {
                methodNames.forEach((name) => {
                    self.enableMethodNames.delete(name);
                });
            },
            change: (methodName, methodArgs) => {
                if (self.enableMethodNames.has(methodName)) {
                    self.updateNativeData(self.cache, methodName, methodArgs);
                }
            }
        };
        this.nativeApi.registerNativeListener(this.listener);
    }
    /**
     * 更新Native数据
     * @param cache         缓存数据
     * @param methodName    要更新的方法名
     * @param methodArgs    要更新的方法参数
     */
    updateNativeData(cache, methodName, methodArgs) {
        const cacheKey = this.generateCacheKey(methodName, methodArgs);
        // 删除该key对应的数据
        cache.delete(cacheKey);
        // 获取到methodName对应的方法
        const fun = this.nativeApi[methodName];
        // 方法存在，可以安全调用，并传入参数
        if (typeof fun === 'function') {
            const result = fun(...methodArgs);
            // 结果存入缓存
            if (result) {
                this.cache.set(cacheKey, result);
            }
        }
    }
    /**
     * 生成cache的存储key
     * @param methodName    方法名
     * @param methodArgs    方法参数
     */
    generateCacheKey(methodName, methodArgs) {
        return `${methodName}_${JSON.stringify(methodArgs)}`;
    }
    get(target, propKey, receiver) {
        const origMethod = Reflect.get(target, propKey, receiver);
        const methodName = `${String(propKey)}`;
        if (typeof origMethod === 'function' && this.enableMethodNames.has(methodName)) {
            return (...args) => {
                const cacheKey = this.generateCacheKey(`${String(propKey)}`, args);
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }
                else {
                    const result = origMethod.apply(target, args);
                    if (result) {
                        // 有效值才存入，null或者undefined存入cache没有意义
                        this.cache.set(cacheKey, result);
                    }
                    return result;
                }
            };
        }
        return origMethod;
    }
}

export { NativeDataCache, SyncCacheProxyHandler };
//# sourceMappingURL=NativeApiSyncCacheProxy.js.map
