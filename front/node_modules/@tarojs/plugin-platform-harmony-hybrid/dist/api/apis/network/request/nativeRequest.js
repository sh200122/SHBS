import { __rest } from '../../../../node_modules/.pnpm/tslib@2.6.2/node_modules/tslib/tslib.es6.js';
import Taro from '@tarojs/api';
import { isFunction } from '@tarojs/shared';
import { toByteArray } from 'base64-js';
import { NativeRequest } from '../../interface/NativeRequest.js';
import { shouldBeObject, getParameterError } from '../../utils/index.js';

const _request = (options) => {
    const name = 'request';
    const isObject = shouldBeObject(options);
    if (!isObject.flag) {
        const res = { errMsg: `${name}:fail ${isObject.msg}` };
        return Promise.reject(res);
    }
    const _a = options, { url, success, fail, complete, method, dataType } = _a, otherOptions = __rest(_a, ["url", "success", "fail", "complete", "method", "dataType"]);
    if (typeof url !== 'string') {
        const res = {
            errMsg: getParameterError({
                para: 'url',
                correct: 'string',
                wrong: url,
            }),
        };
        isFunction(fail) && fail(res);
        isFunction(complete) && complete(res);
        return Promise.reject(res);
    }
    let task;
    const result = new Promise((resolve, reject) => {
        const upperMethod = method ? method.toUpperCase() : method;
        task = NativeRequest.createRequestTask(Object.assign(Object.assign({ url, method: upperMethod, dataType }, otherOptions), { success: (res) => {
                const result = {
                    data: res.data,
                    statusCode: res.statusCode,
                    header: res.header,
                    cookies: res.cookies,
                    errMsg: res.errMsg
                };
                // ���������Ƕ��������ݣ��򽫷���ֵת���� ArrayBuffer
                if (res.isArrayBuffer && dataType === 'arraybuffer') {
                    result.data = toByteArray(res.data).buffer;
                }
                isFunction(success) && success(result);
                isFunction(complete) && complete(result);
                resolve(result);
            }, fail: (res) => {
                isFunction(fail) && fail(res);
                isFunction(complete) && complete(res);
                reject(res);
            } }));
    });
    result.onHeadersReceived = task.onHeadersReceived.bind(task);
    result.offHeadersReceived = task.offHeadersReceived.bind(task);
    result.abort = task.abort.bind(task);
    return result;
};
function taroInterceptor(chain) {
    return _request(chain.requestParams);
}
// @ts-ignore
const { Link } = Taro;
const link = new Link(taroInterceptor);
function request(options) {
    const result = link.request.bind(link)(options);
    result.catch(() => { });
    return result;
}
const addInterceptor = link.addInterceptor.bind(link);
const cleanInterceptors = link.cleanInterceptors.bind(link);

export { _request, addInterceptor, cleanInterceptors, request };
//# sourceMappingURL=nativeRequest.js.map
