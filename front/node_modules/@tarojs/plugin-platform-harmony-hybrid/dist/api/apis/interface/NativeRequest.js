import { fromByteArray } from 'base64-js';
import { ClassInstanceManager } from './ClassInstanceManager.js';

var _a;
class NativeRequest {
    constructor(option) {
        this.className = 'NativeRequest';
        this[_a] = '';
        if ((option === null || option === void 0 ? void 0 : option.data) instanceof ArrayBuffer) {
            option.bufBase64 = fromByteArray(new Uint8Array(option.data));
            option.data = undefined;
        }
        const options = Object.assign(Object.assign({}, option), { success: (res) => {
                option === null || option === void 0 ? void 0 : option.success(res);
                this.destroy();
            }, fail: (res) => {
                option === null || option === void 0 ? void 0 : option.fail(res);
                this.destroy();
            } });
        this.objectId = ClassInstanceManager.getInstance().createInstance(this.className, options);
    }
    static createRequestTask(option) {
        return new NativeRequest(option);
    }
    abort() {
        ClassInstanceManager.getInstance().setInstanceFunction({}, this.className, 'abort', this.objectId);
        this.destroy();
    }
    onHeadersReceived(option) {
        ClassInstanceManager.getInstance().setInstanceFunctionAsync(option, this.className, 'onHeadersReceived', this.objectId);
    }
    offHeadersReceived(option) {
        ClassInstanceManager.getInstance().setInstanceFunction(option, this.className, 'offHeadersReceived', this.objectId);
    }
    catch(onrejected) {
        return Promise.resolve(onrejected);
    }
    offChunkReceived(option) {
        return option;
    }
    onChunkReceived(option) {
        return option;
    }
    destroy() {
        ClassInstanceManager.getInstance().destroyInstance(this.className, this.objectId);
    }
    then(onrejected) {
        return Promise.resolve(onrejected);
    }
    finally(onfinally) {
        throw new Error(onfinally);
    }
}
_a = Symbol.toStringTag;

export { NativeRequest };
//# sourceMappingURL=NativeRequest.js.map
