import {
  createDebug
} from "./chunk-3AUX4FGE.mjs";
import {
  pluginName
} from "./chunk-L7PW3J3N.mjs";
import {
  getCompilerContext
} from "./chunk-3ZZRMLDI.mjs";
import "./chunk-Q67IXIAH.mjs";
import "./chunk-5LMCSUNK.mjs";
import {
  getGroupedEntries,
  removeExt
} from "./chunk-JXBLHLFR.mjs";
import {
  __dirname
} from "./chunk-24KAG666.mjs";

// src/bundlers/webpack/BaseUnifiedPlugin/v4.ts
import fs from "node:fs";
import path from "node:path";
import { ConcatSource, RawSource } from "webpack-sources";
var debug = createDebug();
var UnifiedWebpackPluginV4 = class {
  constructor(options = {}) {
    this.options = getCompilerContext(options);
    this.appType = this.options.appType;
  }
  apply(compiler) {
    const {
      mainCssChunkMatcher,
      disabled,
      onLoad,
      onUpdate,
      onEnd,
      onStart,
      styleHandler,
      templateHandler,
      jsHandler,
      setMangleRuntimeSet,
      runtimeLoaderPath,
      cache,
      twPatcher
    } = this.options;
    if (disabled) {
      return;
    }
    twPatcher.patch();
    function getClassSetInLoader() {
      if (twPatcher.majorVersion !== 4) {
        return twPatcher.getClassSet();
      }
    }
    onLoad();
    const loader = runtimeLoaderPath ?? path.resolve(__dirname, "./weapp-tw-runtime-loader.js");
    const isExisted = fs.existsSync(loader);
    const WeappTwRuntimeAopLoader = {
      loader,
      options: {
        getClassSet: getClassSetInLoader
      },
      ident: null,
      type: null
    };
    compiler.hooks.compilation.tap(pluginName, (compilation) => {
      compilation.hooks.normalModuleLoader.tap(pluginName, (_loaderContext, module) => {
        if (isExisted) {
          const idx = module.loaders.findIndex((x) => x.loader.includes("postcss-loader"));
          if (idx > -1) {
            module.loaders.unshift(WeappTwRuntimeAopLoader);
          }
        }
      });
    });
    compiler.hooks.emit.tapPromise(pluginName, async (compilation) => {
      onStart();
      debug("start");
      for (const chunk of compilation.chunks) {
        if (chunk.id && chunk.hash) {
          cache.calcHashValueChanged(chunk.id, chunk.hash);
        }
      }
      const assets = compilation.assets;
      const entries = Object.entries(assets);
      const groupedEntries = getGroupedEntries(entries, this.options);
      const runtimeSet = await twPatcher.getClassSet();
      setMangleRuntimeSet(runtimeSet);
      debug("get runtimeSet, class count: %d", runtimeSet.size);
      if (Array.isArray(groupedEntries.html)) {
        let noCachedCount = 0;
        for (const element of groupedEntries.html) {
          const [file, originalSource] = element;
          const rawSource = originalSource.source().toString();
          const hash = cache.computeHash(rawSource);
          const cacheKey = file;
          cache.calcHashValueChanged(cacheKey, hash);
          await cache.process(
            cacheKey,
            () => {
              const source = cache.get(cacheKey);
              if (source) {
                compilation.updateAsset(file, source);
                debug("html cache hit: %s", file);
              } else {
                return false;
              }
            },
            // @ts-ignore
            async () => {
              const wxml = await templateHandler(rawSource, {
                runtimeSet
              });
              const source = new ConcatSource(wxml);
              compilation.updateAsset(file, source);
              onUpdate(file, rawSource, wxml);
              debug("html handle: %s", file);
              noCachedCount++;
              return {
                key: cacheKey,
                source
              };
            }
          );
        }
        debug("html handle finish, total: %d, no-cached: %d", groupedEntries.html.length, noCachedCount);
      }
      if (Array.isArray(groupedEntries.js)) {
        let noCachedCount = 0;
        for (const element of groupedEntries.js) {
          const [file, originalSource] = element;
          const cacheKey = removeExt(file);
          await cache.process(
            cacheKey,
            () => {
              const source = cache.get(cacheKey);
              if (source) {
                compilation.updateAsset(file, source);
                debug("js cache hit: %s", file);
              } else {
                return false;
              }
            },
            // @ts-ignore
            async () => {
              const rawSource = originalSource.source().toString();
              const mapFilename = `${file}.map`;
              const hasMap = Boolean(assets[mapFilename]);
              const { code, map } = await jsHandler(rawSource, runtimeSet, {
                generateMap: hasMap
              });
              const source = new ConcatSource(code);
              compilation.updateAsset(file, source);
              onUpdate(file, rawSource, code);
              debug("js handle: %s", file);
              noCachedCount++;
              if (hasMap && map) {
                const source2 = new RawSource(map.toString());
                compilation.updateAsset(mapFilename, source2);
              }
              return {
                key: cacheKey,
                source
              };
            }
          );
        }
        debug("js handle finish, total: %d, no-cached: %d", groupedEntries.js.length, noCachedCount);
      }
      if (Array.isArray(groupedEntries.css)) {
        let noCachedCount = 0;
        for (const element of groupedEntries.css) {
          const [file, originalSource] = element;
          const rawSource = originalSource.source().toString();
          const hash = cache.computeHash(rawSource);
          const cacheKey = file;
          cache.calcHashValueChanged(cacheKey, hash);
          await cache.process(
            cacheKey,
            () => {
              const source = cache.get(cacheKey);
              if (source) {
                compilation.updateAsset(file, source);
                debug("css cache hit: %s", file);
              } else {
                return false;
              }
            },
            // @ts-ignore
            async () => {
              const { css } = await styleHandler(rawSource, {
                isMainChunk: mainCssChunkMatcher(file, this.appType)
              });
              const source = new ConcatSource(css);
              compilation.updateAsset(file, source);
              onUpdate(file, rawSource, css);
              debug("css handle: %s", file);
              noCachedCount++;
              return {
                key: cacheKey,
                source
              };
            }
          );
        }
        debug("css handle finish, total: %d, no-cached: %d", groupedEntries.css.length, noCachedCount);
      }
      debug("end");
      onEnd();
    });
  }
};
export {
  UnifiedWebpackPluginV4
};
