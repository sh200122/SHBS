"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunkLSSLYD6Bjs = require('./chunk-LSSLYD6B.js');


var _chunkEHEK77ROjs = require('./chunk-EHEK77RO.js');


var _chunkG2TGR4BFjs = require('./chunk-G2TGR4BF.js');



var _chunkO335YLYHjs = require('./chunk-O335YLYH.js');

// src/bundlers/webpack/BaseUnifiedPlugin/v5.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var debug = _chunkLSSLYD6Bjs.createDebug.call(void 0, );
var UnifiedWebpackPluginV5 = class {
  constructor(options = {}) {
    this.options = _chunkG2TGR4BFjs.getCompilerContext.call(void 0, options);
    this.appType = this.options.appType;
  }
  apply(compiler) {
    const {
      mainCssChunkMatcher,
      disabled,
      onLoad,
      onUpdate,
      onEnd,
      onStart,
      styleHandler,
      templateHandler,
      jsHandler,
      setMangleRuntimeSet,
      runtimeLoaderPath,
      cache,
      twPatcher
    } = this.options;
    if (disabled) {
      return;
    }
    twPatcher.patch();
    const { Compilation, sources, NormalModule } = compiler.webpack;
    const { ConcatSource, RawSource } = sources;
    function getClassSetInLoader() {
      if (twPatcher.majorVersion !== 4) {
        return twPatcher.getClassSet();
      }
    }
    onLoad();
    const loader = _nullishCoalesce(runtimeLoaderPath, () => ( _path2.default.resolve(__dirname, "./weapp-tw-runtime-loader.js")));
    const isExisted = _fs2.default.existsSync(loader);
    const WeappTwRuntimeAopLoader = {
      loader,
      options: {
        getClassSet: getClassSetInLoader
      },
      ident: null,
      type: null
    };
    compiler.hooks.compilation.tap(_chunkEHEK77ROjs.pluginName, (compilation) => {
      NormalModule.getCompilationHooks(compilation).loader.tap(_chunkEHEK77ROjs.pluginName, (_loaderContext, module) => {
        if (isExisted) {
          const idx = module.loaders.findIndex((x) => x.loader.includes("postcss-loader"));
          if (idx > -1) {
            module.loaders.unshift(WeappTwRuntimeAopLoader);
          }
        }
      });
      compilation.hooks.processAssets.tapPromise(
        {
          name: _chunkEHEK77ROjs.pluginName,
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
        },
        async (assets) => {
          onStart();
          debug("start");
          for (const chunk of compilation.chunks) {
            if (chunk.id && chunk.hash) {
              cache.calcHashValueChanged(chunk.id, chunk.hash);
            }
          }
          const entries = Object.entries(assets);
          const groupedEntries = _chunkO335YLYHjs.getGroupedEntries.call(void 0, entries, this.options);
          const runtimeSet = await twPatcher.getClassSet();
          setMangleRuntimeSet(runtimeSet);
          debug("get runtimeSet, class count: %d", runtimeSet.size);
          if (Array.isArray(groupedEntries.html)) {
            let noCachedCount = 0;
            for (const element of groupedEntries.html) {
              const [file, originalSource] = element;
              const rawSource = originalSource.source().toString();
              const hash = cache.computeHash(rawSource);
              const cacheKey = file;
              cache.calcHashValueChanged(cacheKey, hash);
              await cache.process(
                cacheKey,
                () => {
                  const source = cache.get(cacheKey);
                  if (source) {
                    compilation.updateAsset(file, source);
                    debug("html cache hit: %s", file);
                  } else {
                    return false;
                  }
                },
                async () => {
                  const wxml = await templateHandler(rawSource, {
                    runtimeSet
                  });
                  const source = new ConcatSource(wxml);
                  compilation.updateAsset(file, source);
                  onUpdate(file, rawSource, wxml);
                  debug("html handle: %s", file);
                  noCachedCount++;
                  return {
                    key: cacheKey,
                    source
                  };
                }
              );
            }
            debug("html handle finish, total: %d, no-cached: %d", groupedEntries.html.length, noCachedCount);
          }
          if (Array.isArray(groupedEntries.js)) {
            let noCachedCount = 0;
            for (const element of groupedEntries.js) {
              const [file, originalSource] = element;
              const cacheKey = _chunkO335YLYHjs.removeExt.call(void 0, file);
              await cache.process(
                cacheKey,
                () => {
                  const source = cache.get(cacheKey);
                  if (source) {
                    compilation.updateAsset(file, source);
                    debug("js cache hit: %s", file);
                  } else {
                    return false;
                  }
                },
                async () => {
                  const rawSource = originalSource.source().toString();
                  const mapFilename = `${file}.map`;
                  const hasMap = Boolean(assets[mapFilename]);
                  const { code, map } = await jsHandler(rawSource, runtimeSet, {
                    generateMap: hasMap
                  });
                  const source = new ConcatSource(code);
                  compilation.updateAsset(file, source);
                  onUpdate(file, rawSource, code);
                  debug("js handle: %s", file);
                  noCachedCount++;
                  if (hasMap && map) {
                    const source2 = new RawSource(map.toString());
                    compilation.updateAsset(mapFilename, source2);
                  }
                  return {
                    key: cacheKey,
                    source
                  };
                }
              );
            }
            debug("js handle finish, total: %d, no-cached: %d", groupedEntries.js.length, noCachedCount);
          }
          if (Array.isArray(groupedEntries.css)) {
            let noCachedCount = 0;
            for (const element of groupedEntries.css) {
              const [file, originalSource] = element;
              const rawSource = originalSource.source().toString();
              const hash = cache.computeHash(rawSource);
              const cacheKey = file;
              cache.calcHashValueChanged(cacheKey, hash);
              await cache.process(
                cacheKey,
                () => {
                  const source = cache.get(cacheKey);
                  if (source) {
                    compilation.updateAsset(file, source);
                    debug("css cache hit: %s", file);
                  } else {
                    return false;
                  }
                },
                async () => {
                  const { css } = await styleHandler(rawSource, {
                    isMainChunk: mainCssChunkMatcher(file, this.appType)
                  });
                  const source = new ConcatSource(css);
                  compilation.updateAsset(file, source);
                  onUpdate(file, rawSource, css);
                  debug("css handle: %s", file);
                  noCachedCount++;
                  return {
                    key: cacheKey,
                    source
                  };
                }
              );
            }
            debug("css handle finish, total: %d, no-cached: %d", groupedEntries.css.length, noCachedCount);
          }
          debug("end");
          onEnd();
        }
      );
    });
  }
};



exports.UnifiedWebpackPluginV5 = UnifiedWebpackPluginV5;
