import "./chunk-WAXGOBY2.mjs";

// src/handler.ts
import { defuOverrideArray } from "@weapp-tailwindcss/shared";
import postcss from "postcss";

// src/defaults.ts
function getDefaultOptions() {
  return {
    cssPresetEnv: {
      features: {
        "cascade-layers": true,
        "is-pseudo-class": {
          specificityMatchingName: "weapp-tw-ig"
        },
        "oklab-function": true,
        "color-mix": true,
        "custom-properties": false
      },
      autoprefixer: {
        add: false
      }
    }
  };
}

// src/plugins/index.ts
import postcssPresetEnv from "postcss-preset-env";
import postcssRem2rpx from "postcss-rem-to-responsive-pixel";

// src/symbols.ts
var VariablesScopeSymbol = Symbol("VariablesScope");

// src/plugins/ctx.ts
function createContext() {
  const variablesScopeWeakMap = /* @__PURE__ */ new WeakMap();
  function isVariablesScope(rule) {
    return variablesScopeWeakMap.get(rule) === VariablesScopeSymbol;
  }
  function markVariablesScope(rule) {
    variablesScopeWeakMap.set(rule, VariablesScopeSymbol);
  }
  return {
    variablesScopeWeakMap,
    isVariablesScope,
    markVariablesScope
  };
}

// src/constants.ts
var postcssPlugin = "postcss-weapp-tailwindcss-rename-plugin";

// src/selectorParser.ts
import psp3 from "postcss-selector-parser";

// src/mp.ts
import { Declaration, Rule } from "postcss";
import psp2 from "postcss-selector-parser";

// src/cssVars.ts
var cssVars_default = [
  {
    prop: "--tw-border-spacing-x",
    value: "0"
  },
  {
    prop: "--tw-border-spacing-y",
    value: "0"
  },
  {
    prop: "--tw-translate-x",
    value: "0"
  },
  {
    prop: "--tw-translate-y",
    value: "0"
  },
  {
    prop: "--tw-rotate",
    value: "0"
  },
  {
    prop: "--tw-skew-x",
    value: "0"
  },
  {
    prop: "--tw-skew-y",
    value: "0"
  },
  {
    prop: "--tw-scale-x",
    value: "1"
  },
  {
    prop: "--tw-scale-y",
    value: "1"
  },
  {
    prop: "--tw-pan-x",
    value: " "
  },
  {
    prop: "--tw-pan-y",
    value: " "
  },
  {
    prop: "--tw-pinch-zoom",
    value: " "
  },
  {
    prop: "--tw-scroll-snap-strictness",
    value: "proximity"
  },
  {
    prop: "--tw-gradient-from-position",
    value: " "
  },
  {
    prop: "--tw-gradient-via-position",
    value: " "
  },
  {
    prop: "--tw-gradient-to-position",
    value: " "
  },
  {
    prop: "--tw-ordinal",
    value: " "
  },
  {
    prop: "--tw-slashed-zero",
    value: " "
  },
  {
    prop: "--tw-numeric-figure",
    value: " "
  },
  {
    prop: "--tw-numeric-spacing",
    value: " "
  },
  {
    prop: "--tw-numeric-fraction",
    value: " "
  },
  {
    prop: "--tw-ring-inset",
    value: " "
  },
  {
    prop: "--tw-ring-offset-width",
    value: "0px"
  },
  {
    prop: "--tw-ring-offset-color",
    value: "#fff"
  },
  {
    prop: "--tw-ring-color",
    value: "rgb(59 130 246 / 0.5)"
  },
  {
    prop: "--tw-ring-offset-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-ring-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-shadow-colored",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-blur",
    value: " "
  },
  {
    prop: "--tw-brightness",
    value: " "
  },
  {
    prop: "--tw-contrast",
    value: " "
  },
  {
    prop: "--tw-grayscale",
    value: " "
  },
  {
    prop: "--tw-hue-rotate",
    value: " "
  },
  {
    prop: "--tw-invert",
    value: " "
  },
  {
    prop: "--tw-saturate",
    value: " "
  },
  {
    prop: "--tw-sepia",
    value: " "
  },
  {
    prop: "--tw-drop-shadow",
    value: " "
  },
  {
    prop: "--tw-backdrop-blur",
    value: " "
  },
  {
    prop: "--tw-backdrop-brightness",
    value: " "
  },
  {
    prop: "--tw-backdrop-contrast",
    value: " "
  },
  {
    prop: "--tw-backdrop-grayscale",
    value: " "
  },
  {
    prop: "--tw-backdrop-hue-rotate",
    value: " "
  },
  {
    prop: "--tw-backdrop-invert",
    value: " "
  },
  {
    prop: "--tw-backdrop-opacity",
    value: " "
  },
  {
    prop: "--tw-backdrop-saturate",
    value: " "
  },
  {
    prop: "--tw-backdrop-sepia",
    value: " "
  },
  {
    prop: "--tw-contain-size",
    value: " "
  },
  {
    prop: "--tw-contain-layout",
    value: " "
  },
  {
    prop: "--tw-contain-paint",
    value: " "
  },
  {
    prop: "--tw-contain-style",
    value: " "
  }
];

// src/shared.ts
import { escape, MappingChars2String } from "@weapp-core/escape";
import psp from "postcss-selector-parser";
function internalCssSelectorReplacer(selectors, options = {
  escapeMap: MappingChars2String
}) {
  const { mangleContext, escapeMap } = options;
  if (mangleContext) {
    selectors = mangleContext.cssHandler(selectors);
  }
  return escape(selectors, {
    map: escapeMap
  });
}
function composeIsPseudoAst(strs) {
  if (typeof strs === "string") {
    return [
      psp.tag({
        value: strs
      }),
      psp.combinator({
        value: "+"
      }),
      psp.tag({
        value: strs
      })
    ];
  }
  if (strs.length > 1) {
    return [
      psp.pseudo({
        value: ":is",
        nodes: strs.map(
          (str) => psp.tag({
            value: str
          })
        )
      }),
      psp.combinator({
        value: "+"
      }),
      psp.pseudo({
        value: ":is",
        nodes: strs.map(
          (str) => psp.tag({
            value: str
          })
        )
      })
    ];
  }
  return [
    psp.tag({
      value: strs[0]
    }),
    psp.combinator({
      value: "+"
    }),
    psp.tag({
      value: strs[0]
    })
  ];
}
function composeIsPseudo(strs) {
  if (typeof strs === "string") {
    return strs;
  }
  if (strs.length > 1) {
    return `:is(${strs.join(",")})`;
  }
  return strs.join("");
}

// src/mp.ts
var initialNodes = cssVars_default.map((x) => {
  return new Declaration({
    prop: x.prop,
    value: x.value
  });
});
var PATTERNS = [
  /:not\(template\)\s*[~+]\s*:not\(template\)/.source,
  /:not\(\[hidden\]\)\s*[~+]\s*:not\(\[hidden\]\)/.source
].join("|");
var BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, "g");
function testIfVariablesScope(node, count = 2) {
  if (isOnlyBeforeAndAfterPseudoElement(node)) {
    const nodes = node.nodes;
    let c = 0;
    for (const tryTestDecl of nodes) {
      if (tryTestDecl && tryTestDecl.type === "decl" && tryTestDecl.prop.startsWith("--tw-")) {
        c++;
      }
      if (c >= count) {
        return true;
      }
    }
    return false;
  }
  return false;
}
function testIfTwBackdrop(node, count = 2) {
  if (node.type === "rule" && node.selector === "::backdrop") {
    const nodes = node.nodes;
    let c = 0;
    for (const tryTestDecl of nodes) {
      if (tryTestDecl && tryTestDecl.type === "decl" && tryTestDecl.prop.startsWith("--tw-")) {
        c++;
      }
      if (c >= count) {
        return true;
      }
    }
    return false;
  }
  return false;
}
function makePseudoVarRule() {
  const pseudoVarRule = new Rule({
    // selectors: ['::before', '::after'],
    selector: "::before,::after"
  });
  pseudoVarRule.append(
    new Declaration({
      prop: "--tw-content",
      value: '""'
    })
  );
  return pseudoVarRule;
}
function remakeCssVarSelector(selectors, options) {
  const { cssPreflightRange, cssSelectorReplacement } = options;
  if (cssPreflightRange === "all" && !selectors.includes(":not(not)")) {
    selectors.push(":not(not)");
  }
  if (cssSelectorReplacement) {
    if (Array.isArray(cssSelectorReplacement.universal)) {
      if (!cssSelectorReplacement.universal.every((x) => {
        return selectors.includes(x);
      }) && !selectors.includes("*")) {
        selectors.unshift("*");
      }
    } else if (typeof cssSelectorReplacement.universal === "string" && !selectors.includes(cssSelectorReplacement.universal) && !selectors.includes("*")) {
      selectors.unshift("*");
    }
  }
  return selectors;
}
function getCombinatorSelectorAst(options) {
  let childCombinatorReplaceValue = [
    psp2.tag({ value: "view" }),
    psp2.combinator({ value: "+" }),
    psp2.tag({ value: "view" })
  ];
  const { cssChildCombinatorReplaceValue } = options;
  if (Array.isArray(cssChildCombinatorReplaceValue) && cssChildCombinatorReplaceValue.length > 0) {
    childCombinatorReplaceValue = composeIsPseudoAst(cssChildCombinatorReplaceValue);
  } else if (typeof cssChildCombinatorReplaceValue === "string") {
    childCombinatorReplaceValue = composeIsPseudoAst(cssChildCombinatorReplaceValue);
  }
  return childCombinatorReplaceValue;
}
function commonChunkPreflight(node, options) {
  const { ctx, cssInjectPreflight, injectAdditionalCssVarScope } = options;
  if (testIfVariablesScope(node)) {
    ctx?.markVariablesScope(node);
    node.selectors = remakeCssVarSelector(node.selectors, options);
    node.before(makePseudoVarRule());
    if (typeof cssInjectPreflight === "function") {
      node.append(...cssInjectPreflight());
    }
  }
  if (injectAdditionalCssVarScope && testIfTwBackdrop(node)) {
    const syntheticRule = new Rule({
      selectors: ["*", "::after", "::before"],
      nodes: initialNodes
    });
    syntheticRule.selectors = remakeCssVarSelector(syntheticRule.selectors, options);
    node.before(syntheticRule);
    node.before(makePseudoVarRule());
    if (typeof cssInjectPreflight === "function") {
      syntheticRule.append(...cssInjectPreflight());
    }
  }
}

// src/selectorParser.ts
function createRuleTransform(rule, options) {
  const { escapeMap, mangleContext, cssSelectorReplacement, cssRemoveHoverPseudoClass } = options;
  const transform = (selectors) => {
    selectors.walk((selector, index) => {
      if (selector.type === "universal") {
        if (cssSelectorReplacement?.universal) {
          selector.value = composeIsPseudo(cssSelectorReplacement.universal);
        }
      } else if (selector.type === "selector") {
        if (cssRemoveHoverPseudoClass) {
          const node = selector.nodes.find((x) => x.type === "pseudo" && x.value === ":hover");
          if (node) {
            selector.remove();
          }
        }
      } else if (selector.type === "pseudo") {
        if (selector.value === ":root" && cssSelectorReplacement?.root) {
          selector.value = composeIsPseudo(cssSelectorReplacement.root);
        } else if (selector.value === ":where") {
          if (index === 0 && selector.length === 1) {
            selector.walk((node, idx) => {
              if (idx === 0 && node.type === "class") {
                const nodes = node.parent?.nodes;
                if (nodes) {
                  const first = nodes[idx + 1];
                  if (first && first.type === "combinator" && first.value === ">") {
                    const second = nodes[idx + 2];
                    if (second && second.type === "pseudo" && second.value === ":not" && second.first.first.type === "pseudo" && second.first.first.value === ":last-child") {
                      const ast = getCombinatorSelectorAst(options);
                      second.replaceWith(
                        ...ast
                      );
                    }
                  }
                }
              }
            });
            selector.replaceWith(...selector.nodes);
          }
        }
      } else if (selector.type === "class") {
        selector.value = internalCssSelectorReplacer(selector.value, {
          escapeMap,
          mangleContext
        });
      } else if (selector.type === "combinator") {
        if (selector.value === ">") {
          const nodes = selector.parent?.nodes;
          if (nodes) {
            const first = nodes[index + 1];
            if (first && first.type === "pseudo" && first.value === ":not" && (first.first.first.type === "attribute" && first.first.first.attribute === "hidden" || first.first.first.type === "tag" && first.first.first.value === "template")) {
              const second = nodes[index + 2];
              if (second && second.type === "combinator" && (second.value === "~" || second.value === "+")) {
                const third = nodes[index + 3];
                if (third && third.type === "pseudo" && third.value === ":not" && (third.first.first.type === "attribute" && third.first.first.attribute === "hidden" || third.first.first.type === "tag" && third.first.first.value === "template")) {
                  const ast = getCombinatorSelectorAst(options);
                  selector.parent?.nodes.splice(
                    index + 1,
                    3,
                    ...ast
                  );
                }
              }
            }
          }
        }
      }
    });
    if (selectors.length === 0) {
      rule.remove();
    }
  };
  return transform;
}
function ruleTransformSync(rule, options) {
  const transformer = psp3(createRuleTransform(rule, options));
  return transformer.transformSync(rule, {
    lossless: false,
    updateSelector: true
  });
}
function isOnlyBeforeAndAfterPseudoElement(node) {
  let b = false;
  let a = false;
  psp3((selectors) => {
    selectors.walkPseudos((s) => {
      if (s.parent?.length === 1) {
        if (/^:?:before$/.test(s.value)) {
          b = true;
        }
        if (/^:?:after$/.test(s.value)) {
          a = true;
        }
      }
    });
  }).astSync(node);
  return b && a;
}
function getFallbackRemove(rule) {
  const fallbackRemove = psp3((selectors) => {
    let maybeImportantId = false;
    selectors.walk((selector, idx) => {
      if (idx === 0 && (selector.type === "id" || selector.type === "class" || selector.type === "attribute")) {
        maybeImportantId = true;
      }
      if (selector.type === "universal") {
        selector.parent?.remove();
      }
      if (selector.type === "pseudo") {
        if (selector.value === ":is") {
          if (maybeImportantId && selector.nodes[0]?.type === "selector") {
            selector.replaceWith(selector.nodes[0]);
          } else {
            selector.parent?.remove();
          }
        } else if (selector.value === ":not") {
          for (const x of selector.nodes) {
            if (x.nodes.length === 1 && x.nodes[0].type === "id" && x.nodes[0].value === "#") {
              x.nodes = [
                psp3.tag({
                  value: "#n"
                })
              ];
            }
          }
        } else if (selector.value === ":where") {
          for (const n of selector.nodes) {
            for (const node of n.nodes) {
              if (node.type === "attribute") {
                node.remove();
              }
            }
          }
        }
      }
      if (selector.type === "attribute") {
        if (selector.attribute === "hidden") {
          rule?.remove();
        }
      }
    });
    selectors.walk((selector) => {
      if (selector.type === "pseudo") {
        if (selector.value === ":where") {
          const res = selector.nodes.every((x) => x.nodes.length === 0);
          if (res) {
            selector.remove();
          }
        }
      }
    });
  });
  return fallbackRemove;
}

// src/plugins/post.ts
var OklabSuffix = "in oklab";
var postcssWeappTailwindcssPostPlugin = (options = {
  isMainChunk: true
}) => {
  const { customRuleCallback, isMainChunk } = options;
  const p = {
    postcssPlugin
  };
  if (isMainChunk) {
    p.OnceExit = (root) => {
      root.walkRules((rule) => {
        getFallbackRemove(rule).transformSync(rule, {
          updateSelector: true,
          lossless: false
        });
        if (rule.selectors.length === 0 || rule.selectors.length === 1 && rule.selector.trim() === "") {
          rule.remove();
        }
        rule.walkDecls((decl) => {
          if (decl.prop === "--tw-gradient-position" && decl.value.endsWith(OklabSuffix)) {
            decl.value = decl.value.slice(0, decl.value.length - OklabSuffix.length);
          }
        });
      });
    };
  }
  if (typeof customRuleCallback === "function") {
    p.Rule = (rule) => {
      customRuleCallback(rule, options);
    };
  }
  return p;
};
postcssWeappTailwindcssPostPlugin.postcss = true;

// src/plugins/pre.ts
function isAtMediaHover(atRule) {
  return /media\(\s*hover\s*:\s*hover\s*\)/.test(atRule.name) || atRule.name === "media" && /\(\s*hover\s*:\s*hover\s*\)/.test(atRule.params);
}
var postcssWeappTailwindcssPrePlugin = (options = {
  isMainChunk: true
}) => {
  const { isMainChunk } = options;
  const p = {
    postcssPlugin,
    Rule(rule) {
      ruleTransformSync(rule, options);
    },
    AtRule(atRule) {
      if (isAtMediaHover(atRule)) {
        if (atRule.nodes) {
          atRule.replaceWith(atRule.nodes);
        } else {
          atRule.remove();
        }
      }
    }
  };
  if (isMainChunk) {
    p.Once = (root) => {
      root.walkRules((rule) => {
        commonChunkPreflight(rule, options);
      });
    };
  }
  return p;
};
postcssWeappTailwindcssPrePlugin.postcss = true;

// ../../node_modules/.pnpm/@csstools+postcss-is-pseudo-class@5.0.1_postcss@8.5.3/node_modules/@csstools/postcss-is-pseudo-class/dist/index.mjs
import e2 from "postcss-selector-parser";

// ../../node_modules/.pnpm/@csstools+selector-specificity@5.0.0_postcss-selector-parser@7.1.0/node_modules/@csstools/selector-specificity/dist/index.mjs
import e from "postcss-selector-parser";
function compare(e3, t2) {
  return e3.a === t2.a ? e3.b === t2.b ? e3.c - t2.c : e3.b - t2.b : e3.a - t2.a;
}
function selectorSpecificity(t2, s) {
  const i = s?.customSpecificity?.(t2);
  if (i) return i;
  if (!t2) return { a: 0, b: 0, c: 0 };
  let c = 0, n = 0, o2 = 0;
  if ("universal" == t2.type) return { a: 0, b: 0, c: 0 };
  if ("id" === t2.type) c += 1;
  else if ("tag" === t2.type) o2 += 1;
  else if ("class" === t2.type) n += 1;
  else if ("attribute" === t2.type) n += 1;
  else if (isPseudoElement(t2)) switch (t2.value.toLowerCase()) {
    case "::slotted":
      if (o2 += 1, t2.nodes && t2.nodes.length > 0) {
        const e3 = specificityOfMostSpecificListItem(t2.nodes, s);
        c += e3.a, n += e3.b, o2 += e3.c;
      }
      break;
    case "::view-transition-group":
    case "::view-transition-image-pair":
    case "::view-transition-old":
    case "::view-transition-new":
      return t2.nodes && 1 === t2.nodes.length && "selector" === t2.nodes[0].type && selectorNodeContainsNothingOrOnlyUniversal(t2.nodes[0]) ? { a: 0, b: 0, c: 0 } : { a: 0, b: 0, c: 1 };
    default:
      o2 += 1;
  }
  else if (e.isPseudoClass(t2)) switch (t2.value.toLowerCase()) {
    case ":-webkit-any":
    case ":any":
    default:
      n += 1;
      break;
    case ":-moz-any":
    case ":has":
    case ":is":
    case ":matches":
    case ":not":
      if (t2.nodes && t2.nodes.length > 0) {
        const e3 = specificityOfMostSpecificListItem(t2.nodes, s);
        c += e3.a, n += e3.b, o2 += e3.c;
      }
      break;
    case ":where":
      break;
    case ":nth-child":
    case ":nth-last-child":
      if (n += 1, t2.nodes && t2.nodes.length > 0) {
        const i2 = t2.nodes[0].nodes.findIndex((e3) => "tag" === e3.type && "of" === e3.value.toLowerCase());
        if (i2 > -1) {
          const a = e.selector({ nodes: [], value: "" });
          t2.nodes[0].nodes.slice(i2 + 1).forEach((e3) => {
            a.append(e3.clone());
          });
          const r = [a];
          t2.nodes.length > 1 && r.push(...t2.nodes.slice(1));
          const l = specificityOfMostSpecificListItem(r, s);
          c += l.a, n += l.b, o2 += l.c;
        }
      }
      break;
    case ":local":
    case ":global":
      t2.nodes && t2.nodes.length > 0 && t2.nodes.forEach((e3) => {
        const t3 = selectorSpecificity(e3, s);
        c += t3.a, n += t3.b, o2 += t3.c;
      });
      break;
    case ":host":
    case ":host-context":
      if (n += 1, t2.nodes && t2.nodes.length > 0) {
        const e3 = specificityOfMostSpecificListItem(t2.nodes, s);
        c += e3.a, n += e3.b, o2 += e3.c;
      }
      break;
    case ":active-view-transition":
    case ":active-view-transition-type":
      return { a: 0, b: 1, c: 0 };
  }
  else e.isContainer(t2) && t2.nodes?.length > 0 && t2.nodes.forEach((e3) => {
    const t3 = selectorSpecificity(e3, s);
    c += t3.a, n += t3.b, o2 += t3.c;
  });
  return { a: c, b: n, c: o2 };
}
function specificityOfMostSpecificListItem(e3, t2) {
  let s = { a: 0, b: 0, c: 0 };
  return e3.forEach((e4) => {
    const i = selectorSpecificity(e4, t2);
    compare(i, s) < 0 || (s = i);
  }), s;
}
function isPseudoElement(t2) {
  return e.isPseudoElement(t2);
}
function selectorNodeContainsNothingOrOnlyUniversal(e3) {
  if (!e3) return false;
  if (!e3.nodes) return false;
  const t2 = e3.nodes.filter((e4) => "comment" !== e4.type);
  return 0 === t2.length || 1 === t2.length && "universal" === t2[0].type;
}

// ../../node_modules/.pnpm/@csstools+postcss-is-pseudo-class@5.0.1_postcss@8.5.3/node_modules/@csstools/postcss-is-pseudo-class/dist/index.mjs
function alwaysValidSelector(s) {
  const o2 = e2().astSync(s);
  let t2 = true;
  return o2.walk((e3) => {
    if ("class" !== e3.type && "comment" !== e3.type && "id" !== e3.type && "root" !== e3.type && "selector" !== e3.type && "string" !== e3.type && "tag" !== e3.type && "universal" !== e3.type && ("attribute" !== e3.type || e3.insensitive) && ("combinator" !== e3.type || "+" !== e3.value && ">" !== e3.value && "~" !== e3.value && " " !== e3.value) && ("pseudo" !== e3.type || e3.nodes?.length || ":hover" !== e3.value.toLowerCase() && ":focus" !== e3.value.toLowerCase())) {
      if ("pseudo" === e3.type && 1 === e3.nodes?.length && ":not" === e3.value.toLowerCase()) {
        let s2 = true;
        if (e3.nodes[0].walkCombinators(() => {
          s2 = false;
        }), s2) return;
      }
      return t2 = false, false;
    }
  }), t2;
}
function sortCompoundSelectorsInsideComplexSelector(s) {
  if (!s || !s.nodes || 1 === s.nodes.length) return;
  const o2 = [];
  let t2 = [];
  for (let n2 = 0; n2 < s.nodes.length; n2++) "combinator" !== s.nodes[n2].type ? e2.isPseudoElement(s.nodes[n2]) ? (o2.push(t2), t2 = [s.nodes[n2]]) : t2.push(s.nodes[n2]) : (o2.push(t2), o2.push([s.nodes[n2]]), t2 = []);
  o2.push(t2);
  const n = [];
  for (let e3 = 0; e3 < o2.length; e3++) {
    const s2 = o2[e3];
    s2.sort((e4, s3) => "selector" === e4.type && "selector" === s3.type && e4.nodes.length && s3.nodes.length ? selectorTypeOrder(e4.nodes[0], e4.nodes[0].type) - selectorTypeOrder(s3.nodes[0], s3.nodes[0].type) : "selector" === e4.type && e4.nodes.length ? selectorTypeOrder(e4.nodes[0], e4.nodes[0].type) - selectorTypeOrder(s3, s3.type) : "selector" === s3.type && s3.nodes.length ? selectorTypeOrder(e4, e4.type) - selectorTypeOrder(s3.nodes[0], s3.nodes[0].type) : selectorTypeOrder(e4, e4.type) - selectorTypeOrder(s3, s3.type));
    const t3 = new Set(s2.map((e4) => e4.type)), r = t3.has("universal") && (t3.has("tag") || t3.has("attribute") || t3.has("class") || t3.has("id") || t3.has("pseudo"));
    for (let e4 = 0; e4 < s2.length; e4++) "universal" === s2[e4].type && r ? s2[e4].remove() : n.push(s2[e4]);
  }
  s.removeAll();
  for (let o3 = n.length - 1; o3 >= 0; o3--) {
    const t3 = n[o3 - 1];
    if (n[o3].remove(), t3 && "tag" === t3.type && "tag" === n[o3].type) {
      const t4 = e2.pseudo({ value: ":is", nodes: [e2.selector({ value: "", nodes: [n[o3]] })] });
      t4.parent = s, s.nodes.unshift(t4);
    } else n[o3].parent = s, s.nodes.unshift(n[o3]);
  }
}
function selectorTypeOrder(s, t2) {
  return e2.isPseudoElement(s) ? o.pseudoElement : o[t2];
}
var o = { universal: 0, tag: 1, pseudoElement: 2, id: 3, class: 4, attribute: 5, pseudo: 6, selector: 7, string: 8, root: 9, comment: 10 };
function childAdjacentChild(e3) {
  return !(!e3 || !e3.nodes) && ("selector" === e3.type && (3 === e3.nodes.length && (!(!e3.nodes[0] || "pseudo" !== e3.nodes[0].type || ":-csstools-matches" !== e3.nodes[0].value) && (!(!e3.nodes[1] || "combinator" !== e3.nodes[1].type || "+" !== e3.nodes[1].value && "~" !== e3.nodes[1].value) && (!(!e3.nodes[2] || "pseudo" !== e3.nodes[2].type || ":-csstools-matches" !== e3.nodes[2].value) && (!(!e3.nodes[0].nodes || 1 !== e3.nodes[0].nodes.length) && ("selector" === e3.nodes[0].nodes[0].type && (!(!e3.nodes[0].nodes[0].nodes || 3 !== e3.nodes[0].nodes[0].nodes.length) && (!(!e3.nodes[0].nodes[0].nodes || "combinator" !== e3.nodes[0].nodes[0].nodes[1].type || ">" !== e3.nodes[0].nodes[0].nodes[1].value) && (!(!e3.nodes[2].nodes || 1 !== e3.nodes[2].nodes.length) && ("selector" === e3.nodes[2].nodes[0].type && (!(!e3.nodes[2].nodes[0].nodes || 3 !== e3.nodes[2].nodes[0].nodes.length) && (!(!e3.nodes[2].nodes[0].nodes || "combinator" !== e3.nodes[2].nodes[0].nodes[1].type || ">" !== e3.nodes[2].nodes[0].nodes[1].value) && (e3.nodes[0].nodes[0].insertAfter(e3.nodes[0].nodes[0].nodes[0], e3.nodes[2].nodes[0].nodes[0].clone()), e3.nodes[2].nodes[0].nodes[1].remove(), e3.nodes[2].nodes[0].nodes[0].remove(), e3.nodes[0].replaceWith(e3.nodes[0].nodes[0]), e3.nodes[2].replaceWith(e3.nodes[2].nodes[0]), true))))))))))))));
}
function isInCompoundWithOneOtherElement(s) {
  if (!s || !s.nodes) return false;
  if (!e2.isSelector(s)) return false;
  if (2 !== s.nodes.length) return false;
  let o2 = -1, t2 = -1;
  s.nodes[0] && e2.isPseudoClass(s.nodes[0]) && ":-csstools-matches" === s.nodes[0].value ? (o2 = 0, t2 = 1) : s.nodes[1] && e2.isPseudoClass(s.nodes[1]) && ":-csstools-matches" === s.nodes[1].value && (o2 = 1, t2 = 0);
  const n = s.nodes[o2];
  if (!n || !e2.isPseudoClass(n) || 1 !== n.nodes.length) return false;
  const r = s.nodes[t2];
  return !!r && (!e2.isCombinator(r) && (n.nodes[0].append(r.clone()), n.replaceWith(...n.nodes[0].nodes), r.remove(), true));
}
function isPseudoInFirstCompound(s) {
  if (!s || !s.nodes) return false;
  if (!e2.isSelector(s)) return false;
  let o2 = -1;
  for (let t3 = 0; t3 < s.nodes.length; t3++) {
    const n2 = s.nodes[t3];
    if (e2.isCombinator(n2)) return false;
    if (e2.isPseudoClass(n2) && ":-csstools-matches" === n2.value) {
      if (!n2.nodes || 1 !== n2.nodes.length) return false;
      o2 = t3;
      break;
    }
  }
  const t2 = s.nodes[o2];
  if (!t2 || !e2.isPseudoClass(t2)) return false;
  const n = s.nodes.slice(0, o2), r = s.nodes.slice(o2 + 1);
  return n.forEach((e3) => {
    t2.nodes[0].append(e3.clone());
  }), r.forEach((e3) => {
    t2.nodes[0].append(e3.clone());
  }), t2.replaceWith(...t2.nodes), n.forEach((e3) => {
    e3.remove();
  }), r.forEach((e3) => {
    e3.remove();
  }), true;
}
function complexSelectors(s, o2, t2, n) {
  return s.flatMap((s2) => {
    if (-1 === s2.indexOf(":-csstools-matches") && -1 === s2.toLowerCase().indexOf(":is")) return s2;
    const r = e2().astSync(s2);
    return r.walkPseudos((s3) => {
      if (":is" === s3.value.toLowerCase() && s3.nodes && s3.nodes.length && "selector" === s3.nodes[0].type && 0 === s3.nodes[0].nodes.length) return s3.value = ":not", void s3.nodes[0].append(e2.universal());
      if (":-csstools-matches" === s3.value) if (!s3.nodes || s3.nodes.length) {
        if (s3.walkPseudos((s4) => {
          if (e2.isPseudoElement(s4)) {
            let e3 = s4.value;
            if (e3.startsWith("::-csstools-invalid-")) return;
            for (; e3.startsWith(":"); ) e3 = e3.slice(1);
            s4.value = `::-csstools-invalid-${e3}`, n();
          }
        }), 1 === s3.nodes.length && "selector" === s3.nodes[0].type) {
          if (1 === s3.nodes[0].nodes.length) return void s3.replaceWith(s3.nodes[0].nodes[0]);
          if (!s3.nodes[0].some((e3) => "combinator" === e3.type)) return void s3.replaceWith(...s3.nodes[0].nodes);
        }
        1 !== r.nodes.length || "selector" !== r.nodes[0].type || 1 !== r.nodes[0].nodes.length || r.nodes[0].nodes[0] !== s3 ? childAdjacentChild(s3.parent) || isInCompoundWithOneOtherElement(s3.parent) || isPseudoInFirstCompound(s3.parent) || ("warning" === o2.onComplexSelector && t2(), s3.value = ":is") : s3.replaceWith(...s3.nodes[0].nodes);
      } else s3.remove();
    }), r.walk((e3) => {
      "selector" === e3.type && "nodes" in e3 && 1 === e3.nodes.length && "selector" === e3.nodes[0].type && e3.replaceWith(e3.nodes[0]);
    }), r.walk((e3) => {
      "nodes" in e3 && sortCompoundSelectorsInsideComplexSelector(e3);
    }), r.toString();
  }).filter((e3) => !!e3);
}
function splitSelectors(o2, t2, n = 0) {
  const r = ":not(#" + t2.specificityMatchingName + ")", d = ":not(." + t2.specificityMatchingName + ")", l = ":not(" + t2.specificityMatchingName + ")";
  return o2.flatMap((o3) => {
    if (-1 === o3.toLowerCase().indexOf(":is")) return o3;
    let a = false;
    const i = [];
    if (e2().astSync(o3).walkPseudos((e3) => {
      if (":is" !== e3.value.toLowerCase() || !e3.nodes || !e3.nodes.length) return;
      if ("selector" === e3.nodes[0].type && 0 === e3.nodes[0].nodes.length) return;
      if ("pseudo" === e3.parent?.parent?.type && ":not" === e3.parent?.parent?.value?.toLowerCase()) return void i.push([{ start: e3.parent.parent.sourceIndex, end: e3.parent.parent.sourceIndex + e3.parent.parent.toString().length, option: `:not(${e3.nodes.toString()})` }]);
      if ("pseudo" === e3.parent?.parent?.type && ":has" === e3.parent?.parent?.value?.toLowerCase()) return void (e3.value = ":-csstools-matches");
      let o4 = e3.parent;
      for (; o4; ) {
        if (o4.value && ":is" === o4.value.toLowerCase() && "pseudo" === o4.type) return void (a = true);
        o4 = o4.parent;
      }
      const t3 = selectorSpecificity(e3), n2 = e3.sourceIndex, c2 = n2 + e3.toString().length, p = [];
      e3.nodes.forEach((e4) => {
        const o5 = { start: n2, end: c2, option: "" }, a2 = selectorSpecificity(e4);
        let i2 = e4.toString().trim();
        const u = Math.max(0, t3.a - a2.a), h = Math.max(0, t3.b - a2.b), f = Math.max(0, t3.c - a2.c);
        for (let e5 = 0; e5 < u; e5++) i2 += r;
        for (let e5 = 0; e5 < h; e5++) i2 += d;
        for (let e5 = 0; e5 < f; e5++) i2 += l;
        o5.option = i2, p.push(o5);
      }), i.push(p);
    }), !i.length) return [o3];
    let c = [];
    return cartesianProduct(...i).forEach((e3) => {
      let s = "";
      for (let t3 = 0; t3 < e3.length; t3++) {
        const n2 = e3[t3];
        s += o3.substring(e3[t3 - 1]?.end || 0, e3[t3].start), s += ":-csstools-matches(" + n2.option + ")", t3 === e3.length - 1 && (s += o3.substring(e3[t3].end));
      }
      c.push(s);
    }), a && n < 10 && (c = splitSelectors(c, t2, n + 1)), c;
  }).filter((e3) => !!e3);
}
function cartesianProduct(...e3) {
  const s = [], o2 = e3.length - 1;
  return function helper(t2, n) {
    for (let r = 0, d = e3[n].length; r < d; r++) {
      const d2 = t2.slice(0);
      d2.push(e3[n][r]), n === o2 ? s.push(d2) : helper(d2, n + 1);
    }
  }([], 0), s;
}
var t = /:is\(/i;
var creator = (e3) => {
  const s = { specificityMatchingName: "does-not-exist", ...e3 || {} };
  return { postcssPlugin: "postcss-is-pseudo-class", prepare() {
    const e4 = /* @__PURE__ */ new WeakSet();
    return { postcssPlugin: "postcss-is-pseudo-class", Rule(o2, { result: n }) {
      if (!o2.selector) return;
      if (!t.test(o2.selector)) return;
      if (e4.has(o2)) return;
      let r = false;
      const warnOnComplexSelector = () => {
        "warning" === s.onComplexSelector && (r || (r = true, o2.warn(n, `Complex selectors in '${o2.selector}' can not be transformed to an equivalent selector without ':is()'.`)));
      };
      let d = false;
      const warnOnPseudoElements = () => {
        "warning" === s.onPseudoElement && (d || (d = true, o2.warn(n, `Pseudo elements are not allowed in ':is()', unable to transform '${o2.selector}'`)));
      };
      try {
        let t2 = false;
        const n2 = [], r2 = complexSelectors(splitSelectors(o2.selectors, { specificityMatchingName: s.specificityMatchingName }), { onComplexSelector: s.onComplexSelector }, warnOnComplexSelector, warnOnPseudoElements);
        if (Array.from(new Set(r2)).forEach((s2) => {
          if (o2.selectors.indexOf(s2) > -1) n2.push(s2);
          else {
            if (alwaysValidSelector(s2)) return n2.push(s2), void (t2 = true);
            e4.add(o2), o2.cloneBefore({ selector: s2 }), t2 = true;
          }
        }), n2.length && t2 && (e4.add(o2), o2.cloneBefore({ selectors: n2 })), !s.preserve) {
          if (!t2) return;
          o2.remove();
        }
      } catch (e5) {
        if (!(e5 instanceof Error)) throw e5;
        if (e5.message.indexOf("call stack size exceeded") > -1) throw e5;
        o2.warn(n, `Failed to parse selector "${o2.selector}" with error: ${e5.message}`);
      }
    } };
  } };
};
creator.postcss = true;

// src/plugins/index.ts
import { default as default2 } from "postcss-rem-to-responsive-pixel";
function getPlugins(options) {
  const ctx = createContext();
  options.ctx = ctx;
  const plugins = [
    ...options.postcssOptions?.plugins ?? [],
    postcssWeappTailwindcssPrePlugin(options),
    postcssPresetEnv(options.cssPresetEnv)
  ];
  if (options.rem2rpx) {
    plugins.push(
      postcssRem2rpx(
        typeof options.rem2rpx === "object" ? options.rem2rpx : {
          rootValue: 32,
          propList: ["*"],
          transformUnit: "rpx"
        }
      )
    );
  }
  plugins.push(postcssWeappTailwindcssPostPlugin(options));
  return plugins;
}

// src/preflight.ts
function createInjectPreflight(options) {
  const result = [];
  if (options && typeof options === "object") {
    const entries = Object.entries(options);
    for (const [prop, value] of entries) {
      if (value !== false) {
        result.push({
          prop,
          value: value.toString()
        });
      }
    }
  }
  return () => {
    return result;
  };
}

// src/handler.ts
function styleHandler(rawSource, options) {
  return postcss(
    getPlugins(options)
  ).process(
    rawSource,
    options.postcssOptions?.options ?? {
      from: void 0
    }
  ).async();
}
function createStyleHandler(options) {
  const cachedOptions = defuOverrideArray(
    options,
    getDefaultOptions()
  );
  cachedOptions.cssInjectPreflight = createInjectPreflight(cachedOptions.cssPreflight);
  return (rawSource, opt) => {
    return styleHandler(
      rawSource,
      defuOverrideArray(opt, cachedOptions)
    );
  };
}
export {
  createInjectPreflight,
  createStyleHandler,
  internalCssSelectorReplacer
};
